МиниКинопоиск

## Описание проекта
- Установка зависимостей
```shell
pip install -r requirements.txt

pip install -r requirements.dev.txt
```

- Создание моделей (очистит БД и создаст все модели, указанные в импорте)
```shell
python create_tables.py
```

- Загрузка данных в базу
```shell
python load_fixture.py
```
Скрипт читает файл fixtures.json и загружает данные в базу. Если данные уже загружены - выводит соответсвующее сообщение. 

## Запуск проекта

### Bash (Linux/MACOS)
```shell
export FLASK_APP=run.py
export FLASK_ENV='development'
flask run
```

### CMD (Windows)
```shell
set FLASK_APP=run.py
set FLASK_ENV=development
flask run
```

### PowerShell (Windows)
```shell
$env:FLASK_APP = "run"
$env:FLASK_ENV = "development"
flask run
```

## Запуск тестов
```shell
pytest .
```

### Шаг 1. Создание моделей

Необходимы следующие таблицы:

- Жанры (создана)
- Режиссеры
- Фильмы
- Пользователи

Модель режиссеров имеет те же поля, что и модель с жанрами (заметьте, поле **name** является уникальным).

Модель с фильмами имеет следующие поля:

- **id** - первичный ключ
- **title**- название
- **description** - описание
- **trailer** - ссылка на трейлер
- **year** - год выпуска
- **rating** - рейтинг
- **genre_id** - id жанра
- **director_id**  - id режиссера

Модель пользователя имеет следующие поля:

- **id** - первичный ключ
- **email -** по нему будет осуществлен доступ на сайт (*уникальное*)
- **password** — не забывайте, что пароль тут будет в хешированном виде
- name - имя
- surname - фамилия
- favorite_genre - любимый жанр

> Поля, выделенные жирным являются обязательными к заполнению
> 

Вы можете взять исходные модели, вью и все остальное из одного из стартовых репозиториев. 

[https://github.com/skypro-008/lesson19_project_hard_source](https://github.com/skypro-008/lesson19_project_hard_source)

[https://github.com/skypro-008/lesson19_project_easy_source](https://github.com/skypro-008/lesson19_project_easy_source)

Теперь нужно проверить, что все импортированные модели создаются корректно, и сделать коммит.

### Шаг 2. Создание DAO, сервисов и вьюх для фильмов, жанров и режиссеров

На данном шаге мы реализуем следующие эндпоинты:

- **GET** /movies/
- **GET** /movies/{id}
- **GET** /genres/
- **GET** /genres/{id}
- **GET** /directors/
- **GET** /directors/{id}

Для тех эндпоинтов, которые возвращают несколько записей, нужно организовать пагинацию через URL-параметр page, а на страницу будет возвращать по 12 записей. Параметр page - необязательный, а значит, если он не указан - нужно вернуть все записи.

Так как мы хотим получать Новинки, для эндпонта GET /movies/ нужно еще добавить необязательный параметр status. Если он присутствует и имеет значение new — возвращаем записи в отсортированном виде (самые свежие), иначе возвращаем в том порядке, в котором они лежат в базе. Запрос может выглядеть так:

- */movies/?status=new&page=1*
- */movies/?page=2*/
- */movies/* 

### Шаг 3. Создание страниц авторизации

Для реализации авторизации мы напишем следующие три эндпоинта:

- **POST** /auth/register — передавая  email и пароль, создаем пользователя в системе.
- **POST** /auth/login — передаем email и пароль и, если пользователь прошел аутентификацию, возвращаем пользователю ответ в виде:
    
    ```json
    {
       "access_token": "qwesfsdfa",
       "refresh_token": "kjhgfgjakda",
    }
    ```
    

- **PUT** /auth/login — принимаем пару токенов и, если они валидны, создаем пару новых.

На данном этапе нужно обязательно проверить работу механизма аутентификации через Postman (или используйте любой другой инструмент) 

Теперь сделаем коммит и приступим к последнему шагу.

### Шаг 4. Работа с пользователем

Реализуем следующие эндпоинты:

- **GET** /user/ — получить информацию о пользователе (его профиль).
- **PATCH** /user/ — изменить информацию пользователя (имя, фамилия, любимый жанр).
- **PUT** /user/password — обновить пароль пользователя, для этого нужно отправить два пароля *password_1* и *password_2.*

Для того чтобы все  ссылки корректно работали, их нужно обернуть в декоратор, в котором мы будет проверять переданный токен. 

## Задание со звездочкой

**Добавьте возможность добавлять фильмы в избранное** 

На прошлом шаге мы создавали пользователя, ему нужно добавить поле **favorite_genre** и сделать ссылку на модель с жанрами.

Для хранения понравившихся пользователем фильмов нам понадобится отдельная таблица, которая будет иметь связь «многие ко многим», ее структура:

- user_id
- movie_id

Таким образом, мы сможем однозначно понять, какие фильмы нравятся отдельному пользователю и, например, скольким пользователям понравился отдельный фильм.

Добавьте эндпоинты:

- **POST** /favorites/movies/{movie_id} — добавить фильм к пользователю в Избранное.
- **DELETE** /favorites/movies/{movie_id} — удалить фильм из Избранного.

**Добавьте тесты**

Напишите несколько тестов для DAO

Напишите несколько тестов для сервисов

Напишите несколько тестов на вьюхи

**Напишите документацию**

Напишите хорошую документацию для swager, согласно спецификации с сайта библиотеки [flask_restx](https://flask-restx.readthedocs.io).

## Критерии оценивания

- [ ]  Бизнес логика находится в сервисах
- [ ]  Присутствует слой DAO вокруг моделей
- [ ]  В моделях присутствуют нужные поля
- [ ]  В схемах присутствуют нужные поля и не отдаются лишние поля (пароль)
- [ ]  Отношения у моделей установлены
- [ ]  Отношения в сериализаторе сериализованы корректно
- [ ]  Коды ответов возвращаются согласно правилам REST

